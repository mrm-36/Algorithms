#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <string>\r\n\r\ntemplate <typename T>\r\nclass Node {\r\n\r\nprivate:\r\n  T x;\r\n  Node<T>* parent = nullptr;\r\n  Node<T>* left = nullptr;\r\n  Node<T>* right = nullptr;\r\n\r\npublic:\r\n  Node<T> (T _x, Node<T>* p, Node<T>* l, Node<T>* r){\r\n    x = _x; parent = p; left = l; right = r;\r\n  }\r\n  Node<T> (T _x, Node<T>* p){\r\n    (*this) = Node<T>(_x, p, nullptr, nullptr);\r\n  }\r\n  Node<T> (T _x, T _p, T _l, T _r){\r\n    (*this) = Node<T>(_x, new Node<T>(_p), new Node<T>(_l), new Node<T>(_r));\r\n  }\r\n  Node<T> (T _x) {x = _x;}\r\n\r\n  T getX() {return x;}\r\n  Node<T>* getParent() {return parent;}\r\n  Node<T>* getLeft() {return left;}\r\n  Node<T>* getRight() {return right;}\r\n\r\n  void setX(T _x) {x = _x;}\r\n  void setParent(Node<T>* p) {parent = p;}\r\n  void setLeft(Node<T>* l) {left = l;}\r\n  void setRight(Node<T>* r) {right = r;}\r\n  void setParent(T _p) {parent = new Node<T>(_p);}\r\n  void setLeft(T _l) {left = new Node<T>(_l);}\r\n  void setRight(T _r) {right = new Node<T>(_r);}\r\n\r\n  int nb_of_children(){\r\n    return (left != nullptr) + (right != nullptr);\r\n  }\r\n\r\n  bool isLeaf(){\r\n    return nb_of_children() == 0;\r\n  }\r\n\r\n  void print(){\r\n    std::cout << "NODE: \\n";\r\n    std::cout << "|  x      = " << x << \'\\n\';\r\n    std::cout << "|  parent = " << (parent == nullptr ? -1 : parent->getX()) << \'\\n\';\r\n    std::cout << "|  left   = " << (left == nullptr ? -1 : left->getX()) << \'\\n\';\r\n    std::cout << "|  right  = " << (right == nullptr ? -1 : right->getX()) << \'\\n\';\r\n    std::cout << "------------\\n";\r\n  }\r\n};\r\n\r\ntemplate <typename T>\r\nclass BST {\r\n\r\nprivate:\r\n  Node<T>* root = nullptr;\r\n  int sz = 0;\r\n\r\n  void add(Node<T>* u, Node<T>* p, T x, bool left){\r\n    if (!u) {\r\n      u = new Node<T>(x, p);\r\n      if (left) p->setLeft(u); else p->setRight(u);\r\n      return;\r\n    }\r\n    if (x < u->getX()) add(u->getLeft(), u, x, 1);\r\n    else add(u->getRight(), u, x, 0);\r\n  }\r\n\r\n  int height(Node<T>* u){\r\n    if (!u) return 0;\r\n    return 1 + std::max(height(u->getLeft()), height(u->getRight()));\r\n  }\r\n\r\n  Node<T>* find(Node<T>* u, T x){\r\n    if (!u) return u;\r\n    if (x < u->getX()) return find(u->getLeft(), x);\r\n    if (x > u->getX()) return find(u->getRight(), x);\r\n    return u;\r\n  }\r\n\r\n  void dfs(Node<T>* u, std::vector<Node<T>*>& v){\r\n    if (!u) return;\r\n    v.push_back(u);\r\n    dfs(u->getLeft()); dfs(u->getRight());\r\n  }\r\n\r\n  void print_indented(Node<T>* u, std::string x, int l){\r\n    if (!u) return;\r\n    std::cout << x << (l == 1 ? "lt_" : (l == 0 ? "rt_" : "")) << u->getX() << \'\\n\';\r\n    print_indented(u->getLeft(), x + "| ", 1);\r\n    print_indented(u->getRight(), x + "| ", 0);\r\n  }\r\n\r\npublic:\r\n  BST() {}\r\n\r\n  int size() {return sz;}\r\n  bool isEmpty() {return size() == 0;}\r\n  int height() {return height(getRoot()) - 1;}\r\n  Node<T>* getRoot() {return root;}\r\n\r\n  Node<T>* getMin(Node<T>* u){\r\n    while (u && u->getLeft()) u = u->getLeft();\r\n    return u;\r\n  }\r\n\r\n  void add(T x){\r\n    if (!root) root = new Node<T>(x);\r\n    else add(getRoot(), nullptr, x, 0);\r\n  }\r\n\r\n  Node<T>* find(T x) {return find(getRoot(), x);}\r\n\r\n  void remove(T x){\r\n    Node<T>* u = find(x);\r\n    if (!u) return;\r\n    --sz;\r\n    if (u->isLeaf()){\r\n      Node<T>* p = u->getParent();\r\n      if (!p) root = nullptr;\r\n      else {\r\n        if (p->getLeft() == u) p->setLeft(nullptr);\r\n        else p->setRight(nullptr);\r\n      }\r\n      return;\r\n    }\r\n    if (!u->getRight()){\r\n      Node<T>* p = u->getParent();\r\n      if (!p) root = nullptr;\r\n      else {\r\n        if (p->getLeft() == u) p->setLeft(u->getLeft());\r\n        else p->setRight(u->getLeft());\r\n      }\r\n      return;\r\n    }\r\n    if (!u->getLeft()){\r\n      Node<T>* p = u->getParent();\r\n      if (!p) root = nullptr;\r\n      else {\r\n        if (p->getLeft() == u) p->setLeft(u->getRight());\r\n        else p->setRight(u->getRight());\r\n      }\r\n      return;\r\n    }\r\n    ++sz;\r\n    Node<T>* successor = getMin(u->getRight());\r\n    const T k = successor->getX();\r\n    remove(k); u->setX(k);\r\n    return;\r\n  }\r\n\r\n  void print(Node<T>* u){\r\n    if (!u) return;\r\n    std::cout << u->getX() << \' \';\r\n    print(u->getLeft()); print(u->getRight());\r\n  }\r\n\r\n  std::vector<Node<T>*> dfs(Node<T>* u) {\r\n    std::vector<Node<T>*> v;\r\n    dfs(u, v);\r\n    return v;\r\n  }\r\n\r\n  std::vector<Node<T>*> bfs(Node<T>* u){\r\n    std::vector<Node<T>*> arr;\r\n    std::queue<Node<T>*> q;\r\n    if (u) q.push(u);\r\n    while (!q.empty()){\r\n      Node<T>* v = q.front(); q.pop();\r\n      arr.push_back(v);\r\n      if (v->getLeft()) q.push(v->getLeft());\r\n      if (v->getRight()) q.push(v->getRight());\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  void print_indented(){\r\n    print_indented(getRoot(), "", -1);\r\n  }\r\n};\r\n\r\nint main(){\r\n  BST<int> tree;\r\n  for (int i = 1; i <= 3; ++i){\r\n    tree.add(2 * i); tree.add(i); tree.add(2 * i + 1);\r\n  }\r\n  tree.print_indented();\r\n}